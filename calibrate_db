#!/usr/bin/env python
import os
import sys
import numpy as np
import argparse
import netCDF4
import shutil
import time
import datetime


def main():
    parser = argparse.ArgumentParser(description='Climate adjust all lead-times in a NetCDF database')
    parser.add_argument('file', help='NetCDF database')
    parser.add_argument('-o', type=str, help="Output file", dest="ofile", required=True)
    parser.add_argument('--debug', help='Show debug info', action="store_true")
    parser.add_argument('-a', help='Do calibration aggregated across all gridpoints', dest="aggregated", action="store_true")
    parser.add_argument('-lt', help='Which leadtimes to use for calibration?', dest="leadtimes")
    parser.add_argument('-v', help='Which variables to calibrate?', dest="variables")
    parser.add_argument('-f', help='Overwrite output file if it already exists', dest="overwrite", action="store_true")

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    args = parser.parse_args()

    if args.file == args.ofile:
        print("Input file must be different than the output file")
        sys.exit()

    if args.overwrite or not os.path.exists(args.ofile):
        shutil.copy(args.file, args.ofile)
    ifile = netCDF4.Dataset(args.file, 'r')

    # Which calibration function to use on each variable?
    var2func = {"air_temperature_2m": quantile_mapping,
          "precipitation_amount_acc": quantile_mapping,
          "sea_level_pressure": addition,
          "cloud_area_fraction": quantile_mapping,
          "dew_point_temperature_2m": quantile_mapping}

    var_acc = ['precipitation_amount_acc']

    # Which variables to calibrate
    if args.variables is not None:
        vars = args.variables.split(',')
    else:
        vars = [var for var in ifile.variables if var not in ["x", "y", "z", "latitude", "longitude", "time", "lead_time", "projection_regular_ll", "altitude"]]

    # Write to output file
    leadtimes = ifile.variables["lead_time"][:]
    Ileadtimes = range(len(leadtimes))
    has_single_spatial_dim = "grid_point" in ifile.dimensions
    ofile = netCDF4.Dataset(args.ofile, 'a')
    for var in vars:
        print("Processing variable " + var)
        sys.stdout.flush()
        if var not in var2func:
            print("No calibration function for %s defined. Skipping." % var)
            ofile.variables[var].calibration = "None"
            ofile.close()
            continue
        func = var2func[var]

        """
        For each leadtime, find the leadtime to use as reference. This will
        be the earliest leadtime for the same time of day.
        """
        if var in var_acc:
            Irefs = [np.where(leadtimes[i] % 24 == leadtimes % 24)[0][0] for i in Ileadtimes[1:]]
        else:
            Irefs = [np.where(leadtimes[i] % 24 == leadtimes % 24)[0][0] for i in Ileadtimes]

        """
        Gridded calibration: Apply a separate calibration on each grid point
        """
        if not args.aggregated:
            data = ifile.variables[var][:]
            if var in var_acc:
                data = np.diff(data, axis=1)

            # time, lead_time, ens, lat, lon
            if has_single_spatial_dim:
                G = data.shape[3]
            else:
                Y = data.shape[3]
                X = data.shape[4]
            print("Allocating %d GB" % (np.product(ofile.variables[var].shape) / 1024.0 / 1024.0 / 1024.0 * 4.0))
            q = np.zeros(ofile.variables[var].shape, float)

            if has_single_spatial_dim:
                for g in range(G):
                    for i in Ileadtimes:
                        Iref = Irefs[i]
                        if i == Iref:
                            # Don't calibrate if reference leadtime
                            q[:, i, :, g] = data[:, i, :, g]
                        else:
                            yy = np.sort(data[:, Iref, :, g].flatten())
                            xx = np.sort(data[:, i, :, g].flatten())
                            values = func(data[:, i, :, g].flatten(), xx, yy)

                            reshaped = np.reshape(values, [ofile.variables[var].shape[0], ofile.variables[var].shape[2]])
                            q[:, i, :, g] = reshaped[:]
            else:
                """
                It might be possible to parallelize x and y, but it requires some work
                to parallelize the calibration functions
                """
                for x in range(X):
                    for y in range(Y):
                        for i in Ileadtimes:
                            Iref = Irefs[i]
                            if i == Iref:
                                # Don't calibrate if reference leadtime
                                q[:, i, :, y, x] = data[:, i, :, y, x]
                            else:
                                yy = np.sort(data[:, Iref, :, y, x].flatten())
                                xx = np.sort(data[:, i, :, y, x].flat)
                                values = func(data[:, i, :, y, x].flat, xx, yy)

                                reshaped = np.reshape(values, [ofile.variables[var].shape[0], ofile.variables[var].shape[2]])
                                q[:, i, :, y, x] = reshaped
            ofile.variables[var][:] = q
        else:
            data = ifile.variables[var]
            for i in Ileadtimes:
                s = time.time()
                Iref = Irefs[i]
                if i == Iref:
                    ofile.variables[var][:, i, ...] = ifile.variables[var][:, i, ...]
                else:
                    dataref = data[:, Iref, ...]
                    xx = np.sort(data[:, i, ...].flatten())
                    yy = np.sort(dataref[:, ...].flatten())
                    values = func(ifile.variables[var][:, i, ...].flatten(), xx, yy)
                    shape = [size for size in ofile.variables[var].shape]
                    shape = [shape[j] for j in range(len(shape)) if j != 1]
                    reshaped = np.reshape(values, shape)
                    ofile.variables[var][:, i, ...] = reshaped[:]
        ofile.variables[var].calibration = func.__name__
        ofile.sync()

    # Add history string
    command = ' '.join(sys.argv[1:])
    history_str = "%s calibrate_db %s" % (datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S +00:00'), command)
    if hasattr(ifile, "history"):
        history_str = [history_str, ifile.history]
    ofile.history = history_str

    ifile.close()
    ofile.close()


def addition(x, xx, yy):
    bias = np.mean(yy, dtype=np.float64) - np.mean(xx, dtype=np.float64)
    return x + bias


def multiplication(x, xx, yy):
    bias = np.mean(yy, dtype=np.float64) / np.mean(xx, dtype=np.float64)
    return x * bias


def quantile_mapping(x, xx, yy, min=None):
    """
    Arguments:
       x (np.array): x-axis values to interpolate to
       xx (np.array): x-axis control points
       yy (np.array): y-axis control points 
       min (float): Minimum value

    xx and yy must be sorted
   
    Returns:
       y (np.array): y-axis interpolated values
    """
    return np.interp(x, xx, yy)


if __name__ == "__main__":
    main()
